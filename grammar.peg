// Author: Jeeyoung Kim
// PEG grammar file.
// select COLUMNS where
// X = VALUE
// Y IN (VALUES)
// , for AND

{
  # Helper functions. You write coffeescript code here.
  makeNode = (type, params={}) ->
    params.type = type
    return params

  @make = {
    literal: (literal) ->
      makeNode("literal", {value: literal})
    columns: (columns) ->
      makeNode("columns", {columns: columns})
    show: (columns, predicate) ->
      makeNode("show", {columns, predicate})
    select: (computes, predicate, group, range, sample) ->
      makeNode("select", {computes, predicate, group, range, sample})
    # predicates
    predicateSingle: (key, values) ->
      makeNode("predicate", {key, values, subtype: 'single'})
    predicateAnd: (predicates) ->
      makeNode("predicate", {values: predicates, subtype: 'and'})
  }
  @SPACE_NODE = makeNode("whitespace")
  @COMMA_NODE = makeNode("comma")
}

// language for querying metric definition/
// naming conventions
// statements - top level
// expr - sublevel.
// list - anything that homogenous list of things.
// literal - anything that resolves to regex.

start = SHOW_STATEMENT / SELECT_STATEMENT

SELECT_STATEMENT =
  "SELECT"i _
  computes:COMPUTE_EXPR_LIST _
  predicate:PREDICATE_EXPR? _
  group:GROUP_EXPR? _
  range:RANGE_EXPR? _
  sample:SAMPLE_EXPR?  {
  @make.select(computes, predicate, group, range, sample)
}

// compute expressions

COMPUTE_EXPR_LIST = left:COMPUTE_EXPR right:(_ COMMA _ COMPUTE_EXPR)* {
  # todo - extract
  computes = [left]
  for nodes in right
    for node in nodes
      computes.push node
  computes
}

COMPUTE_EXPR = COMPUTE_ADD_EXPR

COMPUTE_ADD_EXPR =
  COMPUTE_MULT_EXPR _ COMPUTE_OP_ADDITION _ COMPUTE_ADD_EXPR /
  COMPUTE_MULT_EXPR

COMPUTE_MULT_EXPR =
  COMPUTE_SINGLE_EXPR _ COMPUTE_OP_MULTIPLICATION _ COMPUTE_MULT_EXPR /
  COMPUTE_SINGLE_EXPR

COMPUTE_SINGLE_EXPR =
  FUNCTION_LITERAL _ "(" _ COMPUTE_EXPR_LIST _ ")" /
  "(" COMPUTE_ADD_EXPR ")" /
  VARIABLE_LITERAL

COMPUTE_OP_ADDITION =       [+-]
COMPUTE_OP_MULTIPLICATION = [*/]

// group expressions

GROUP_EXPR = "GROUP"i _ "BY"i _ COLUMN_LIST

RANGE_EXPR = "RANGE"i _ "(" _ TIME_EXPR _ COMMA _ TIME_EXPR _ ")"

SAMPLE_EXPR = "SAMPLE"i _ "TO"i _ RESOLUTION_EXPR _ "BY"i _ SAMPLER_LITERAL

RESOLUTION_EXPR = [0-9]+ _ DURATION_UNIT_LITERAL

TIME_EXPR = "?" / STRING_LITERAL // todo

SHOW_STATEMENT =  "SHOW"i _ columns: COLUMN_LIST _ predicate: PREDICATE_EXPR? {
  @make.show columns, predicate
}

COLUMN_LIST = left:COLUMN right:(_ COMMA _ COLUMN)* {
  columns = [left.value]
  for nodes in right
    for node in nodes
      if node.type is 'literal'
        columns.push node.value
  @make.columns(columns)
}

COLUMN = COLUMN_LITERAL

PREDICATE_EXPR = "WHERE"i _ list: PREDICATE_LIST { list }

PREDICATE_LIST = left:PREDICATE right:(_ COMMA _ PREDICATE)* {
  predicates = []
  predicates.push left
  for nodes in right
    for node in nodes
      if node.type is 'predicate'
        predicates.push node
  @make.predicateAnd predicates
}

PREDICATE =
  key:COLUMN_LITERAL _ "=" _ value:VALUE_LITERAL {
    @make.predicateSingle(key.value, [value.value])
  } /
  key:COLUMN_LITERAL _ "IN"i _ "(" _ values:VALUE_LIST _ ")" {
    @make.predicateSingle(key.value, values)
  }

VALUE_LIST = left:VALUE_LITERAL right:(_ COMMA _ VALUE_LITERAL)* {
  values = [left.value]
  for nodes in right
    for node in nodes
      if node.type is 'literal'
        values.push node.value
  values
}

// Literals

VALUE_LITERAL = STRING_LITERAL

NUMBER_LITERAL = [0-9]+ / ([0-9]+ "." [0-9]+)

STRING_LITERAL =
  value: $ ('"' ([^"])* '"') {@make.literal value} /
  value: $ ("'" ([^'])* "'") {@make.literal value} /
  value: $ ([a-zA-Z0-9.]+)   {@make.literal value}

FUNCTION_LITERAL =      value: $ [a-zA-Z]+             {@make.literal value}
VARIABLE_LITERAL =      value: $ [a-zA-Z0-9.]+         {@make.literal value}
DURATION_UNIT_LITERAL = value: $ [a-z]+                {@make.literal value}
SAMPLER_LITERAL =       value: $ [a-z]+                {@make.literal value}
COLUMN_LITERAL =        value: $ ([a-zA-Z0-9.]+ / "*") {@make.literal value}

// represents ignorable whitespace.
_ = [ ]* { this.SPACE_NODE }

COMMA = "," { this.COMMA_NODE }
